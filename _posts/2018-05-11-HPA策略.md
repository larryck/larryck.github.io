---
title: HPA策略
description: 
categories:
- k8s
tags:
- cluster
---

之前被问到了HPA如何使用Heapster中的数据。本文对这个问题做进一步研究。主要回答一下几个问题：
>- Heapster提供时序数据，HPA如何使用一段时间的性能数据？
>- HPA多长时间判断一次是否应该调整POD数目？
>- HPA的调整策略是什么样的？

本文的分析版本是K8S V1.6.7。

# HPA执行逻辑
HPAController需要提供一个metricsClient用于获取metrics数据依据，由ControllerManager的HorizontalPodAutoscalerUseRESTClients选项决定是使用RESTMetricsClient还是LegacyClient（Heapster）。在v1.6.7版本中，默认使用的是基于Heapster的LegacyClient。

HPAController使用一个RateLimiting queue保存所有的HPA对象。RateLimiting Workqueue限定了每个HPA的处理间隔，在K8S中为HorizontalPodAutoscalerSyncPeriod（30S）。也就意味着，每隔30S HPAControler会同步HPA对象的状态，获取metrics并决定是否调整pod的个数。

computeReplicasForMetrics为HPAController根据不同的MetricSourceType获取对应的metrics，并根据metrics以及相关的target计算得到replicaCountProposal。我们将在后面讨论replicaCountProposal的计算策略。

获得了目标replicaCount之后，shouldScale决定是否需要调整replicas数目。具体的策略是：
>- 目标POD个数是否与当前个数相等
>- 如果目标个数小于当前个数，metrics获取时间距上次调整时间是否已经过了向下调整时间窗口。downscaleForbiddenWindow时间为5分钟。
>- 如果目标个数大于当前个数，metrics获取时间距上次调整时间是否已经过了向上调整时间窗口。upscaleForbiddenWindow时间为3分钟。

如果确认需要调整replicas数目，接下来通过update接口分别更新hpa对象的Relicas以及status。

# 由metrics计算desireReplicas
computeReplicasForMetrics将根据metricSpec.Type的不同使用不同的计算方式。在1.6.7版本中，HPAController支持三种类型：ObjectMetricSourceType、PodsMetricSourceType、ResourceMetricSourceType三种类型。然而Heapster client并不支持object metrics，因而在这里我们不分析这种类型的逻辑。

## ResourceMetricSourceType类型
ResourceMetricSourceType通过TargetAverageValue是否设置来判断是使用TargetAverageValue还是TargetAverageUtilization用于计算replicas。

**TargetAverageUtilization**
GetResourceReplicas用于根据targetUtilization计算目标Replicas个数。首先，metricsClient从“/apis/metrics/v1alpha1/namespaces/%s/pods”路径通过labelSelector获取对应的Pod的最新性能数据，目前只包括内存和cpu的性能数据。Heapster的apis接口与api接口使用的是相同的数据来源，只不过只返回最新的一个性能值，我们将在之后的文章[heapster的访问接口](https://larryck.github.io/k8s/2018/05/13/Heapster访问接口/)中进一步讨论。

HPAController将Pod下所有的container request值累加作为这个Pod的request值。使用HPA特性时，所有的container必须设置资源request值，否者这里会返回错误。接下来，HPAController将使用metrics以及requests计算资源利用率：当前selector下所有的pod的资源使用值之和metricsTotal与所有request之和的比值requestsTotal。这个资源利用率与目标资源利用率的大小对比即可以决定当前调整是将增加replicas的数目还是减少replicas的值。

接下来，HPAController将获得selector对应的所有pod，并且区分哪些pod是unready（非running状态，或者ready接口状态错误），哪些pod是missing（未获得metrics）。如果需要增加replicas，则将missing pods的资源利用率视为0；如果需要减少replicas，则将missing pods的资源利用率视为1。对于unready pods，在增加replicas时资源利用率视为0。这么调整之后重新计算整个selector对应的pods的资源利用率以及目标资源利用率之间的比值UsageRatio将作为desireReplicas数目的最终依据。

HPA能够容忍0.1的资源浮动，如果UsageRatio>1.1或者UsageRatio<0.9，HPAController将调整replicas值，最终的目标值为**pod个数*UsageRatio**。

**TargetAverageValue**
TargetAverageValue标准的计算方法与TargetAverageUtilization的计算方法类似，只不过如果UsageRatio的计算并不是资源利用率的比值，而是资源利用值得比值。这里不再叙述。

## PodsMetricSourceType类型
PodsMetricSourceType类型只使用TargetAverageValue作为衡量标准，与ResourceMetricSourceType类型的TargetAverageValue标准计算方法类似，不同之处在于metrics的计算。PodsMetricSourceType从heapster的"/api/v1/model/namespaces/%s/pod-list/%s/metrics/%s"获取5分钟前到现在metrics数据，返回的是一个性能数据的时间序列。HPAController将每个pod的最近一分钟内数据的平均值作为该pod的资源利用值。其他的计算与TargetAverageValue类型的计算方法一样。

PodsMetricSourceType类型与ResourceMetricSourceType类型的一个很大的区别是PodsMetricSourceType类型可以支持多种性能数据，ResourceMetricSourceType类型目前只有cpu和memeory两个性能数据。

至此，文章之前疑惑的三个问题已经回答，接下来我们将研究heapster的数据访问接口。



